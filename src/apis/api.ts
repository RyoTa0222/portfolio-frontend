/* tslint:disable */
/* eslint-disable */
/**
 * ポートフォリオのAPIインタフェース定義
 * ポートフォリオのAPIインタフェース定義
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: awpjdmga1943@icloud.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration'
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 *
 * @export
 * @interface Author
 */
export interface Author {
  /**
   * 著者名
   * @type {string}
   * @memberof Author
   */
  name: string
  /**
   * 説明
   * @type {string}
   * @memberof Author
   */
  description: string
  /**
   * 画像データ
   * @type {string}
   * @memberof Author
   */
  image: string
  /**
   * 著者ID
   * @type {string}
   * @memberof Author
   */
  id: string
}
/**
 *
 * @export
 * @interface BlogContent
 */
export interface BlogContent {
  /**
   * タイトル
   * @type {string}
   * @memberof BlogContent
   */
  title: string
  /**
   * ブログID
   * @type {string}
   * @memberof BlogContent
   */
  id: string
  /**
   * 作成日
   * @type {string}
   * @memberof BlogContent
   */
  created_at: string
  /**
   *
   * @type {Tag}
   * @memberof BlogContent
   */
  tag: Tag
  /**
   * 画像データ
   * @type {string}
   * @memberof BlogContent
   */
  image?: string
}
/**
 *
 * @export
 * @interface BlogContentElement
 */
export interface BlogContentElement {
  /**
   * 要素のタイプ
   * @type {string}
   * @memberof BlogContentElement
   */
  type: string
  /**
   * 文字
   * @type {string}
   * @memberof BlogContentElement
   */
  text: string
  /**
   * 画像データ
   * @type {string}
   * @memberof BlogContentElement
   */
  image: string
  /**
   * URL
   * @type {string}
   * @memberof BlogContentElement
   */
  url: string
  /**
   *
   * @type {BlogContentElementReference}
   * @memberof BlogContentElement
   */
  reference: BlogContentElementReference | null
}
/**
 *
 * @export
 * @interface BlogContentElementReference
 */
export interface BlogContentElementReference {
  /**
   * タイトル
   * @type {string}
   * @memberof BlogContentElementReference
   */
  title?: string
  /**
   * 説明
   * @type {string}
   * @memberof BlogContentElementReference
   */
  description?: string
  /**
   * 画像データ
   * @type {string}
   * @memberof BlogContentElementReference
   */
  image?: string
}
/**
 *
 * @export
 * @interface BlogContentsFilteringTag
 */
export interface BlogContentsFilteringTag {
  /**
   *
   * @type {BlogContentsFilteringWithoutTagData}
   * @memberof BlogContentsFilteringTag
   */
  data: BlogContentsFilteringWithoutTagData
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof BlogContentsFilteringTag
   */
  success: boolean
}
/**
 *
 * @export
 * @interface BlogContentsFilteringWithoutTag
 */
export interface BlogContentsFilteringWithoutTag {
  /**
   *
   * @type {BlogContentsFilteringWithoutTagData}
   * @memberof BlogContentsFilteringWithoutTag
   */
  data: BlogContentsFilteringWithoutTagData
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof BlogContentsFilteringWithoutTag
   */
  success: boolean
}
/**
 *
 * @export
 * @interface BlogContentsFilteringWithoutTagData
 */
export interface BlogContentsFilteringWithoutTagData {
  /**
   *
   * @type {Array<BlogContent>}
   * @memberof BlogContentsFilteringWithoutTagData
   */
  contents?: Array<BlogContent>
  /**
   *
   * @type {BlogContentsFilteringWithoutTagDataPage}
   * @memberof BlogContentsFilteringWithoutTagData
   */
  page?: BlogContentsFilteringWithoutTagDataPage
}
/**
 *
 * @export
 * @interface BlogContentsFilteringWithoutTagDataPage
 */
export interface BlogContentsFilteringWithoutTagDataPage {
  /**
   *
   * @type {number}
   * @memberof BlogContentsFilteringWithoutTagDataPage
   */
  current: number
  /**
   *
   * @type {number}
   * @memberof BlogContentsFilteringWithoutTagDataPage
   */
  total_count: number
}
/**
 *
 * @export
 * @interface IndexTitle
 */
export interface IndexTitle {
  /**
   * ラベル
   * @type {string}
   * @memberof IndexTitle
   */
  label: string
  /**
   * タイトルのタイプ
   * @type {string}
   * @memberof IndexTitle
   */
  type: IndexTitleTypeEnum
}

export const IndexTitleTypeEnum = {
  H1: 'h1',
  H2: 'h2',
  H3: 'h3',
  H4: 'h4',
  H5: 'h5',
  H6: 'h6',
} as const

export type IndexTitleTypeEnum =
  typeof IndexTitleTypeEnum[keyof typeof IndexTitleTypeEnum]

/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   * 評価のタイプ
   * @type {string}
   * @memberof InlineObject
   */
  type: InlineObjectTypeEnum
  /**
   * ブログID
   * @type {string}
   * @memberof InlineObject
   */
  id: string
  /**
   * アクション
   * @type {string}
   * @memberof InlineObject
   */
  action: InlineObjectActionEnum
}

export const InlineObjectTypeEnum = {
  Good: 'good',
  Bad: 'bad',
} as const

export type InlineObjectTypeEnum =
  typeof InlineObjectTypeEnum[keyof typeof InlineObjectTypeEnum]
export const InlineObjectActionEnum = {
  Increment: 'increment',
  Decrement: 'decrement',
} as const

export type InlineObjectActionEnum =
  typeof InlineObjectActionEnum[keyof typeof InlineObjectActionEnum]

/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {Array<PortfolioWorks>}
   * @memberof InlineResponse200
   */
  data: Array<PortfolioWorks>
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse200
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {Array<PortfolioShops>}
   * @memberof InlineResponse2001
   */
  data: Array<PortfolioShops>
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2001
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {InlineResponse2002Data}
   * @memberof InlineResponse2002
   */
  data: InlineResponse2002Data
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2002
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2002Data
 */
export interface InlineResponse2002Data {
  /**
   *
   * @type {Array<TimeArchive>}
   * @memberof InlineResponse2002Data
   */
  monthly_archives: Array<TimeArchive>
  /**
   *
   * @type {Array<TagArchive>}
   * @memberof InlineResponse2002Data
   */
  tag_archives: Array<TagArchive>
  /**
   *
   * @type {Array<Tag>}
   * @memberof InlineResponse2002Data
   */
  tags: Array<Tag>
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {InlineResponse2003Data}
   * @memberof InlineResponse2003
   */
  data: InlineResponse2003Data
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2003
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2003Data
 */
export interface InlineResponse2003Data {
  /**
   * タイトル
   * @type {string}
   * @memberof InlineResponse2003Data
   */
  title: string
  /**
   * 画像データ
   * @type {string}
   * @memberof InlineResponse2003Data
   */
  image: string
  /**
   * 作成日
   * @type {string}
   * @memberof InlineResponse2003Data
   */
  created_at: string
  /**
   * 更新日
   * @type {string}
   * @memberof InlineResponse2003Data
   */
  updated_at: string
  /**
   *
   * @type {object}
   * @memberof InlineResponse2003Data
   */
  content: object
  /**
   *
   * @type {object}
   * @memberof InlineResponse2003Data
   */
  entry: object | null
  /**
   *
   * @type {object}
   * @memberof InlineResponse2003Data
   */
  asset: object | null
  /**
   *
   * @type {Author}
   * @memberof InlineResponse2003Data
   */
  author: Author
  /**
   *
   * @type {InlineResponse2003DataLgtm}
   * @memberof InlineResponse2003Data
   */
  lgtm: InlineResponse2003DataLgtm
  /**
   *
   * @type {Array<IndexTitle>}
   * @memberof InlineResponse2003Data
   */
  index: Array<IndexTitle>
  /**
   *
   * @type {Tag}
   * @memberof InlineResponse2003Data
   */
  tag: Tag
}
/**
 *
 * @export
 * @interface InlineResponse2003DataLgtm
 */
export interface InlineResponse2003DataLgtm {
  /**
   *
   * @type {number}
   * @memberof InlineResponse2003DataLgtm
   */
  good: number
  /**
   *
   * @type {number}
   * @memberof InlineResponse2003DataLgtm
   */
  bad: number
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {InlineResponse2003DataLgtm}
   * @memberof InlineResponse2004
   */
  data: InlineResponse2003DataLgtm
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2004
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {InlineResponse2005Data}
   * @memberof InlineResponse2005
   */
  data: InlineResponse2005Data
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2005
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2005Data
 */
export interface InlineResponse2005Data {
  /**
   *
   * @type {Array<NewsItem>}
   * @memberof InlineResponse2005Data
   */
  contents?: Array<NewsItem>
  /**
   *
   * @type {number}
   * @memberof InlineResponse2005Data
   */
  total?: number
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {InlineResponse2006Data}
   * @memberof InlineResponse2006
   */
  data: InlineResponse2006Data
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2006
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2006Data
 */
export interface InlineResponse2006Data {
  /**
   *
   * @type {Array<RoadmapItem>}
   * @memberof InlineResponse2006Data
   */
  schedule?: Array<RoadmapItem>
  /**
   *
   * @type {Array<RoadmapItem>}
   * @memberof InlineResponse2006Data
   */
  develop?: Array<RoadmapItem>
  /**
   *
   * @type {Array<RoadmapItem>}
   * @memberof InlineResponse2006Data
   */
  merge?: Array<RoadmapItem>
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {Array<Author>}
   * @memberof InlineResponse2007
   */
  data: Array<Author>
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2007
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   *
   * @type {Author}
   * @memberof InlineResponse2008
   */
  data: Author
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse2008
   */
  success: boolean
}
/**
 *
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
  /**
   * エラーメッセージ
   * @type {string}
   * @memberof InlineResponse400
   */
  message?: string
  /**
   * 成功ならtrueを、失敗ならfalseを返す
   * @type {boolean}
   * @memberof InlineResponse400
   */
  success?: boolean
}
/**
 *
 * @export
 * @interface NewsItem
 */
export interface NewsItem {
  /**
   * ID
   * @type {string}
   * @memberof NewsItem
   */
  id: string
  /**
   * 日付
   * @type {string}
   * @memberof NewsItem
   */
  date: string
  /**
   * テキスト
   * @type {string}
   * @memberof NewsItem
   */
  text: string
  /**
   *
   * @type {NewsItemImage}
   * @memberof NewsItem
   */
  image: NewsItemImage | null
}
/**
 * 画像データ
 * @export
 * @interface NewsItemImage
 */
export interface NewsItemImage {
  /**
   * URL
   * @type {string}
   * @memberof NewsItemImage
   */
  url?: string
  /**
   * alt
   * @type {string}
   * @memberof NewsItemImage
   */
  alt?: string
}
/**
 *
 * @export
 * @interface PortfolioShops
 */
export interface PortfolioShops {
  /**
   * 画像データ
   * @type {string}
   * @memberof PortfolioShops
   */
  image: string
  /**
   * タイトル
   * @type {string}
   * @memberof PortfolioShops
   */
  title: string
  /**
   * 説明
   * @type {string}
   * @memberof PortfolioShops
   */
  description: string
  /**
   * リンク
   * @type {string}
   * @memberof PortfolioShops
   */
  link: string | null
}
/**
 *
 * @export
 * @interface PortfolioWorks
 */
export interface PortfolioWorks {
  /**
   * 画像データ
   * @type {string}
   * @memberof PortfolioWorks
   */
  image: string
  /**
   * タイトル
   * @type {string}
   * @memberof PortfolioWorks
   */
  title: string
  /**
   * 説明
   * @type {string}
   * @memberof PortfolioWorks
   */
  description: string
  /**
   * リンク
   * @type {string}
   * @memberof PortfolioWorks
   */
  link?: string | null
  /**
   * githubのリンク
   * @type {string}
   * @memberof PortfolioWorks
   */
  github?: string | null
  /**
   * 製作した年
   * @type {number}
   * @memberof PortfolioWorks
   */
  year: number
}
/**
 *
 * @export
 * @interface RoadmapItem
 */
export interface RoadmapItem {
  /**
   * テキスト
   * @type {string}
   * @memberof RoadmapItem
   */
  label: string
  /**
   * trueなら完了
   * @type {boolean}
   * @memberof RoadmapItem
   */
  completed: boolean
}
/**
 *
 * @export
 * @interface Tag
 */
export interface Tag {
  /**
   * ラベル
   * @type {string}
   * @memberof Tag
   */
  label: string
  /**
   * 色
   * @type {string}
   * @memberof Tag
   */
  color: string
  /**
   * タグID
   * @type {string}
   * @memberof Tag
   */
  tag_id: string
  /**
   * ID
   * @type {string}
   * @memberof Tag
   */
  id: string
  /**
   * アイコン
   * @type {string}
   * @memberof Tag
   */
  icon: string
}
/**
 *
 * @export
 * @interface TagArchive
 */
export interface TagArchive {
  /**
   * 並び順
   * @type {number}
   * @memberof TagArchive
   */
  order: number
  /**
   * 割合（%）
   * @type {number}
   * @memberof TagArchive
   */
  percentage: number
  /**
   * カウント
   * @type {number}
   * @memberof TagArchive
   */
  count: number
  /**
   *
   * @type {Array<string>}
   * @memberof TagArchive
   */
  series?: Array<string>
}
/**
 *
 * @export
 * @interface TimeArchive
 */
export interface TimeArchive {
  /**
   * 年月別のアーカイブのラベル
   * @type {string}
   * @memberof TimeArchive
   */
  label: string
  /**
   * カウント
   * @type {number}
   * @memberof TimeArchive
   */
  count: number
}

/**
 * AuthorApi - axios parameter creator
 * @export
 */
export const AuthorApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * 著者データを取得する
     * @summary 著者データを取得する
     * @param {string} id 著者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthor: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAuthor', 'id', id)
      const localVarPath = `/author/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * 著者のリストを取得する
     * @summary 著者のリストを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthors: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/authors`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthorApi - functional programming interface
 * @export
 */
export const AuthorApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthorApiAxiosParamCreator(configuration)
  return {
    /**
     * 著者データを取得する
     * @summary 著者データを取得する
     * @param {string} id 著者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthor(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthor(
        id,
        options,
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * 著者のリストを取得する
     * @summary 著者のリストを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAuthors(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthors(
        options,
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * AuthorApi - factory interface
 * @export
 */
export const AuthorApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthorApiFp(configuration)
  return {
    /**
     * 著者データを取得する
     * @summary 著者データを取得する
     * @param {string} id 著者ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthor(id: string, options?: any): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .getAuthor(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * 著者のリストを取得する
     * @summary 著者のリストを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthors(options?: any): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .getAuthors(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthorApi - object-oriented interface
 * @export
 * @class AuthorApi
 * @extends {BaseAPI}
 */
export class AuthorApi extends BaseAPI {
  /**
   * 著者データを取得する
   * @summary 著者データを取得する
   * @param {string} id 著者ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorApi
   */
  public getAuthor(id: string, options?: AxiosRequestConfig) {
    return AuthorApiFp(this.configuration)
      .getAuthor(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * 著者のリストを取得する
   * @summary 著者のリストを取得する
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthorApi
   */
  public getAuthors(options?: AxiosRequestConfig) {
    return AuthorApiFp(this.configuration)
      .getAuthors(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * BlogApi - axios parameter creator
 * @export
 */
export const BlogApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * ブログの設定の取得
     * @summary ブログの設定の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlog: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/blog`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * ブログのコンテンツの取得
     * @summary ブログのコンテンツの取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {string} [searchWord] 検索ワード
     * @param {string} [tag] タグ
     * @param {string} [time] 絞り込み期間
     * @param {string} [series] シリーズのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlogContents: async (
      offset: number,
      limit: number,
      searchWord?: string,
      tag?: string,
      time?: string,
      series?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'offset' is not null or undefined
      assertParamExists('getBlogContents', 'offset', offset)
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('getBlogContents', 'limit', limit)
      const localVarPath = `/blog/contents`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (searchWord !== undefined) {
        localVarQueryParameter['search_word'] = searchWord
      }

      if (tag !== undefined) {
        localVarQueryParameter['tag'] = tag
      }

      if (time !== undefined) {
        localVarQueryParameter['time'] =
          (time as any) instanceof Date
            ? (time as any).toISOString().substr(0, 10)
            : time
      }

      if (series !== undefined) {
        localVarQueryParameter['series'] = series
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * ブログのコンテンツ詳細の取得
     * @summary ブログのコンテンツ詳細の取得
     * @param {string} id ブログのID
     * @param {number} [preview] プレビューモードかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlogContentsDetail: async (
      id: string,
      preview?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getBlogContentsDetail', 'id', id)
      const localVarPath = `/blog/contents/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (preview !== undefined) {
        localVarQueryParameter['preview'] = preview
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * ブログの評価を取得する
     * @summary ブログの評価を取得する
     * @param {string} id ブログのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlogContentsLgtm: async (
      id: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getBlogContentsLgtm', 'id', id)
      const localVarPath = `/blog/contents/lgtm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (id !== undefined) {
        localVarQueryParameter['id'] = id
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * ブログの評価をする
     * @summary ブログの評価をする
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postBlogContentsLgtm: async (
      inlineObject: InlineObject,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'inlineObject' is not null or undefined
      assertParamExists('postBlogContentsLgtm', 'inlineObject', inlineObject)
      const localVarPath = `/blog/contents/lgtm`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        inlineObject,
        localVarRequestOptions,
        configuration,
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BlogApi - functional programming interface
 * @export
 */
export const BlogApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BlogApiAxiosParamCreator(configuration)
  return {
    /**
     * ブログの設定の取得
     * @summary ブログの設定の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlog(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBlog(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * ブログのコンテンツの取得
     * @summary ブログのコンテンツの取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {string} [searchWord] 検索ワード
     * @param {string} [tag] タグ
     * @param {string} [time] 絞り込み期間
     * @param {string} [series] シリーズのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlogContents(
      offset: number,
      limit: number,
      searchWord?: string,
      tag?: string,
      time?: string,
      series?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<
        BlogContentsFilteringWithoutTag | BlogContentsFilteringTag
      >
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBlogContents(
        offset,
        limit,
        searchWord,
        tag,
        time,
        series,
        options,
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * ブログのコンテンツ詳細の取得
     * @summary ブログのコンテンツ詳細の取得
     * @param {string} id ブログのID
     * @param {number} [preview] プレビューモードかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlogContentsDetail(
      id: string,
      preview?: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2003>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBlogContentsDetail(
          id,
          preview,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * ブログの評価を取得する
     * @summary ブログの評価を取得する
     * @param {string} id ブログのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlogContentsLgtm(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getBlogContentsLgtm(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * ブログの評価をする
     * @summary ブログの評価をする
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async postBlogContentsLgtm(
      inlineObject: InlineObject,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.postBlogContentsLgtm(
          inlineObject,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * BlogApi - factory interface
 * @export
 */
export const BlogApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BlogApiFp(configuration)
  return {
    /**
     * ブログの設定の取得
     * @summary ブログの設定の取得
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlog(options?: any): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .getBlog(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * ブログのコンテンツの取得
     * @summary ブログのコンテンツの取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {string} [searchWord] 検索ワード
     * @param {string} [tag] タグ
     * @param {string} [time] 絞り込み期間
     * @param {string} [series] シリーズのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlogContents(
      offset: number,
      limit: number,
      searchWord?: string,
      tag?: string,
      time?: string,
      series?: string,
      options?: any,
    ): AxiosPromise<
      BlogContentsFilteringWithoutTag | BlogContentsFilteringTag
    > {
      return localVarFp
        .getBlogContents(offset, limit, searchWord, tag, time, series, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * ブログのコンテンツ詳細の取得
     * @summary ブログのコンテンツ詳細の取得
     * @param {string} id ブログのID
     * @param {number} [preview] プレビューモードかどうか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlogContentsDetail(
      id: string,
      preview?: number,
      options?: any,
    ): AxiosPromise<InlineResponse2003> {
      return localVarFp
        .getBlogContentsDetail(id, preview, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * ブログの評価を取得する
     * @summary ブログの評価を取得する
     * @param {string} id ブログのID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlogContentsLgtm(
      id: string,
      options?: any,
    ): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .getBlogContentsLgtm(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * ブログの評価をする
     * @summary ブログの評価をする
     * @param {InlineObject} inlineObject
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    postBlogContentsLgtm(
      inlineObject: InlineObject,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .postBlogContentsLgtm(inlineObject, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * BlogApi - object-oriented interface
 * @export
 * @class BlogApi
 * @extends {BaseAPI}
 */
export class BlogApi extends BaseAPI {
  /**
   * ブログの設定の取得
   * @summary ブログの設定の取得
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogApi
   */
  public getBlog(options?: AxiosRequestConfig) {
    return BlogApiFp(this.configuration)
      .getBlog(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * ブログのコンテンツの取得
   * @summary ブログのコンテンツの取得
   * @param {number} offset 何番目から取得するか
   * @param {number} limit 何個取得するか
   * @param {string} [searchWord] 検索ワード
   * @param {string} [tag] タグ
   * @param {string} [time] 絞り込み期間
   * @param {string} [series] シリーズのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogApi
   */
  public getBlogContents(
    offset: number,
    limit: number,
    searchWord?: string,
    tag?: string,
    time?: string,
    series?: string,
    options?: AxiosRequestConfig,
  ) {
    return BlogApiFp(this.configuration)
      .getBlogContents(offset, limit, searchWord, tag, time, series, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * ブログのコンテンツ詳細の取得
   * @summary ブログのコンテンツ詳細の取得
   * @param {string} id ブログのID
   * @param {number} [preview] プレビューモードかどうか
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogApi
   */
  public getBlogContentsDetail(
    id: string,
    preview?: number,
    options?: AxiosRequestConfig,
  ) {
    return BlogApiFp(this.configuration)
      .getBlogContentsDetail(id, preview, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * ブログの評価を取得する
   * @summary ブログの評価を取得する
   * @param {string} id ブログのID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogApi
   */
  public getBlogContentsLgtm(id: string, options?: AxiosRequestConfig) {
    return BlogApiFp(this.configuration)
      .getBlogContentsLgtm(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * ブログの評価をする
   * @summary ブログの評価をする
   * @param {InlineObject} inlineObject
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlogApi
   */
  public postBlogContentsLgtm(
    inlineObject: InlineObject,
    options?: AxiosRequestConfig,
  ) {
    return BlogApiFp(this.configuration)
      .postBlogContentsLgtm(inlineObject, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * NewsApi - axios parameter creator
 * @export
 */
export const NewsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * ニュースのコンテンツの取得
     * @summary ニュースのコンテンツの取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNews: async (
      offset: number,
      limit: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'offset' is not null or undefined
      assertParamExists('getNews', 'offset', offset)
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('getNews', 'limit', limit)
      const localVarPath = `/news`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * NewsApi - functional programming interface
 * @export
 */
export const NewsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = NewsApiAxiosParamCreator(configuration)
  return {
    /**
     * ニュースのコンテンツの取得
     * @summary ニュースのコンテンツの取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNews(
      offset: number,
      limit: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getNews(
        offset,
        limit,
        options,
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * NewsApi - factory interface
 * @export
 */
export const NewsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = NewsApiFp(configuration)
  return {
    /**
     * ニュースのコンテンツの取得
     * @summary ニュースのコンテンツの取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNews(
      offset: number,
      limit: number,
      options?: any,
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .getNews(offset, limit, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * NewsApi - object-oriented interface
 * @export
 * @class NewsApi
 * @extends {BaseAPI}
 */
export class NewsApi extends BaseAPI {
  /**
   * ニュースのコンテンツの取得
   * @summary ニュースのコンテンツの取得
   * @param {number} offset 何番目から取得するか
   * @param {number} limit 何個取得するか
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NewsApi
   */
  public getNews(offset: number, limit: number, options?: AxiosRequestConfig) {
    return NewsApiFp(this.configuration)
      .getNews(offset, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * ポートフォリオの商品一覧の取得。
     * @summary ポートフォリオの商品一覧の取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {'stamp' | 'product' | 'wallpaper'} [shopType] ショップのタイプ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPortfolioShops: async (
      offset: number,
      limit: number,
      shopType?: 'stamp' | 'product' | 'wallpaper',
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'offset' is not null or undefined
      assertParamExists('getPortfolioShops', 'offset', offset)
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('getPortfolioShops', 'limit', limit)
      const localVarPath = `/portfolio/shops`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (shopType !== undefined) {
        localVarQueryParameter['shopType'] = shopType
      }

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * ポートフォリオの製作物一覧の取得。
     * @summary ポートフォリオの製作物一覧の取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPortfolioWorks: async (
      offset: number,
      limit: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'offset' is not null or undefined
      assertParamExists('getPortfolioWorks', 'offset', offset)
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('getPortfolioWorks', 'limit', limit)
      const localVarPath = `/portfolio/works`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PortfolioApiAxiosParamCreator(configuration)
  return {
    /**
     * ポートフォリオの商品一覧の取得。
     * @summary ポートフォリオの商品一覧の取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {'stamp' | 'product' | 'wallpaper'} [shopType] ショップのタイプ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPortfolioShops(
      offset: number,
      limit: number,
      shopType?: 'stamp' | 'product' | 'wallpaper',
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPortfolioShops(
          offset,
          limit,
          shopType,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
    /**
     * ポートフォリオの製作物一覧の取得。
     * @summary ポートフォリオの製作物一覧の取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPortfolioWorks(
      offset: number,
      limit: number,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPortfolioWorks(
          offset,
          limit,
          options,
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PortfolioApiFp(configuration)
  return {
    /**
     * ポートフォリオの商品一覧の取得。
     * @summary ポートフォリオの商品一覧の取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {'stamp' | 'product' | 'wallpaper'} [shopType] ショップのタイプ
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPortfolioShops(
      offset: number,
      limit: number,
      shopType?: 'stamp' | 'product' | 'wallpaper',
      options?: any,
    ): AxiosPromise<InlineResponse2001> {
      return localVarFp
        .getPortfolioShops(offset, limit, shopType, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * ポートフォリオの製作物一覧の取得。
     * @summary ポートフォリオの製作物一覧の取得
     * @param {number} offset 何番目から取得するか
     * @param {number} limit 何個取得するか
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPortfolioWorks(
      offset: number,
      limit: number,
      options?: any,
    ): AxiosPromise<InlineResponse200> {
      return localVarFp
        .getPortfolioWorks(offset, limit, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
  /**
   * ポートフォリオの商品一覧の取得。
   * @summary ポートフォリオの商品一覧の取得
   * @param {number} offset 何番目から取得するか
   * @param {number} limit 何個取得するか
   * @param {'stamp' | 'product' | 'wallpaper'} [shopType] ショップのタイプ
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public getPortfolioShops(
    offset: number,
    limit: number,
    shopType?: 'stamp' | 'product' | 'wallpaper',
    options?: AxiosRequestConfig,
  ) {
    return PortfolioApiFp(this.configuration)
      .getPortfolioShops(offset, limit, shopType, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * ポートフォリオの製作物一覧の取得。
   * @summary ポートフォリオの製作物一覧の取得
   * @param {number} offset 何番目から取得するか
   * @param {number} limit 何個取得するか
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public getPortfolioWorks(
    offset: number,
    limit: number,
    options?: AxiosRequestConfig,
  ) {
    return PortfolioApiFp(this.configuration)
      .getPortfolioWorks(offset, limit, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RoadmapApi - axios parameter creator
 * @export
 */
export const RoadmapApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * ロードマップを取得する
     * @summary ロードマップを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoadMap: async (
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/roadmap`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RoadmapApi - functional programming interface
 * @export
 */
export const RoadmapApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RoadmapApiAxiosParamCreator(configuration)
  return {
    /**
     * ロードマップを取得する
     * @summary ロードマップを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoadMap(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<InlineResponse2006>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoadMap(
        options,
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      )
    },
  }
}

/**
 * RoadmapApi - factory interface
 * @export
 */
export const RoadmapApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = RoadmapApiFp(configuration)
  return {
    /**
     * ロードマップを取得する
     * @summary ロードマップを取得する
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoadMap(options?: any): AxiosPromise<InlineResponse2006> {
      return localVarFp
        .getRoadMap(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RoadmapApi - object-oriented interface
 * @export
 * @class RoadmapApi
 * @extends {BaseAPI}
 */
export class RoadmapApi extends BaseAPI {
  /**
   * ロードマップを取得する
   * @summary ロードマップを取得する
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoadmapApi
   */
  public getRoadMap(options?: AxiosRequestConfig) {
    return RoadmapApiFp(this.configuration)
      .getRoadMap(options)
      .then((request) => request(this.axios, this.basePath))
  }
}
